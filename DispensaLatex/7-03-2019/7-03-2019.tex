

\newpage
\section{7-03-2019}
\textbf{WILDCARDS} \newline
I tre tipi possibili di wildcards sono: \newline
\textbullet\ \textit{<?> top type} (o chiamato Unbounded Wildcard) \newline
\textbullet\ \textit{<? extends nametype>} (o chiamato Upper Bounded Wildcards)\newline
\textbullet\ \textit{<? super nametype >} (o chiamato Lower Bounded Wildcards)\newline

\begin{lstlisting}[basicstyle=\small,]
/* TOP TYPE*/ 
List<?> l1 = new ArrayList<Cane>();
/* Il "?" da solo indica un tipo che gerarchicamente
 * e più in alto di Object, viene detto top type.
 * In poche parole indica che non ci sono 
 * restrizioni sul tipo di parametro passato,
 * e che quindi la lista contiene un tipo non
 * conosciuto */

l1.get(int index) /* il compilatore ritorna l'errore in
				   * compile- time:  " capture of ? " 
				   * qualcosa che sia figlio del top type */
				   
/* List<?> significa che creo una lista di un tipo
 * sconosciuto. In conseguenza di ciò il compilatore 
 * mi segnala errore quando cerco di richiamare il
 * metodo l1.add("qualcosa") perchè non è di
 * tipo sconosciuto.	
/*
			   
\end{lstlisting}

\noindent Il tipo "?" non può essere usato come tipo per una variabile quindi dichiarare"? x" non si può fare. Posso però dichiarare questo: "Object x = l1.get(..)" \newline




Mentre ? extends Animale -> qualsiasi cosa che sia figlio di animale \newline
l2.get(0) -> ritorna un capture of ? extends Animale -> qualsiasi cosa figlia di animale (posso però fare Binding di qualcosa che sia al massimo Animale) \newline

\begin{lstlisting}[basicstyle=\small,]
	List<Animale> t3 = new ArrayList<Gatto>();
	/* è errato, si può subscrivere solamente il guscio
	 * esterno, la versione corretta è fatta con il 
	 * wildcard */
	
	List<? extends Animale> t3 = new ArrayList<Gatto>();
\end{lstlisting}

\noindent Posso subsumero solo il tipo esterno, se voglio subsumere anche il tipo interno devo usare le wildcards. \newline

\noindent Il caso simmetrico è il seguente: \newline
? super Animale -> qualcosa che sia più su di Animale (più generale) \newline
In questo caso posso passare animale a tutto quello che sta sopra
l2.add(new Animale) -> ?? non compila perchè... \newline

\noindent Riprenderemo la map vista nella lezione scorsa. Ad esempio, per trasformare animali in piante: 

\begin{lstlisting}[basicstyle=\small,]
public static class Vegetale{}

public static void main_map(){
	List<cani> l1 = new ArrayList<>();
	List<Vegetali> l2 = map(l1, new func<Animale, Vegetale>(){
		@Override
		public Vegetale execute(Animale a){
			return null;
		}
	
	});
}
\end{lstlisting}

\noindent Questa funzione riportata sopra non compila in quanto i \textit{generics} non sono soggetti alla subsumption. Per farla compilare modifichiamo la funzione map come segue: 

\begin{lstlisting}[basicstyle=\small,]
public static  <x, y> List<x> map(List<x>, Func(? super <x, y> f)){
...

}
\end{lstlisting}

Riporto anche una versione il più generale possibile: \newline

\begin{lstlisting}[basicstyle=\small,]
    public static <X, Y> List<Y> map(List<X> l, Func<? super X, ? extends Y> f) {
        List<Y> r = new ArrayList<>();
        for (X x : l) {
            r.add(f.execute(x));
        }
        return r;
    } 
\end{lstlisting}

\noindent \textbf{NESTED CLASS}\newline
La Nested Class (o Inner Class) è totalmente senza relazione rispetto alla enclosed class (outer class).Nel caso precedente main{\_}functional è la enclosed class, in quanto sto lavorando su quella. \newline
Le nested class vedono i campi della enclosing class, compreso il parametro implicito this, solamente se non sono \textit{statiche}.

\noindent \textbf{OVERLOADING} \newline
Il meccanismo dell'overloading permette di definire metodi con stesso nome ma firma diversa. 

\begin{lstlisting}[basicstyle=\small,]
public static class c{
	public int m(){
		return 1;
	}
	public int m(int x){
		return x+1;
	}
	public int m(float x){
		return (int)(x-1.0f);
	}
	public int m(int x, int y){
		return x+y;
	}		
}
\end{lstlisting}

\noindent L'overloading non è permesso cambiando il tipo di ritorno e lasciando il resto inalterato. Devono essere diversi i solo i parametri! \newline
-ordine \newline
-tipi \newline
-numeri \newline

\noindent L'overloading è del tutto gestito dal compilatore, e \textbf{non} viene quindi fatto durante la run-time.

\begin{lstlisting}[basicstyle=\small,]
public Number m(Number x){
	return x;
}
\end{lstlisting}























