

\newpage
\section{4-03-2019}
\textbf{DESIGN PATTERN} \newline
\textbullet\ Iteratore \newline
\textbullet\ Compact o callback ounary function 

\noindent Le \textit{LAMBDA ASTRAZIONI} servono per fare funzioni al "volo", senza dover implementare in classi separate delle interfacce	

\noindent \textbf{FUNZIONI DI ORDINE SUPERIORE} \newline
Sono delle funzioni che prendono delle funzioni come parametri di ingresso 
\begin{lstlisting}[basicstyle=\small,]

\\ questa interfaccia essere equivalente alla interfaccia java.util.Functional
public interface Func<A, B>{
	B execute(A a); \\ questa essere l unica funzione esposta dalla interfaccia
	\\un altro nome ragionevole per il metodo execute() essere apply() oppure call()
	\\il nome deve ricordare il fatto di richiamare la funzione 
}

public static <A,B> List<B> map(List<A> I, Func<A,B> f){
	List<B> r = new ArrayList<>();
	for(A x: l)
		r.add(f.execute(x));
	return r;

}

\end{lstlisting}
A e B sono \textit{generics} locali al metodo(e solo al metodo) \newline
I generics sulle classi servono per parametrizzare, non per fare polimorfismo \newline
\begin{lstlisting}[basicstyle=\small,]

public static <A,B> List<B> map(List<A> I, Func<A,B> f){
\\ dove in public static <A,B> dichiaro i parametri che useremo
\\ mentre in List<a> .. Func <A,B> "uso" i parametri

\end{lstlisting}

\noindent Funzione FILTER: 
\begin{lstlisting}[basicstyle=\small,]

public static <A> List<A> Filter (List<A> l, Func<A,Boolean> p){
	List<A> r = new ArrayList<>();
	for(A x : l)
		if(p.execute(x))
			r.add(x);
	return r;
}

\end{lstlisting}

\noindent La seguente funzione NON funziona perché usa la remove() delle Collection, ma non è possibile rimuove un elemento in fase di scorrimento (è scritto nella documentazione)

\begin{lstlisting}[basicstyle=\small,]

public static <A> void Filter2 (List<A>, Func<A, boolean> p){
	for(A a: l)  //il for each in Java essere zucchero sintattico
		if(p.execute(a))
			l.remove(a);

}

\end{lstlisting}
Se non posso rimuovere come ho fatto sopra un elemento posso invece chiedere all'iteratore di rimuovere l'elemento stesso, esso rimuoverà quello a cui stiamo puntando

\begin{lstlisting}[basicstyle=\small,]

// questo funziona perche chiama la remove() dell'iteratore
public static <A> void Filter2 (List<A>, Func<A, boolean> p){
	Iterator<A> it = l.iterator();
	while(it.hasNext()){
		A a = it.next();
		if(!(p.execute(a)))
			it.remove();
	}
}

\\volendo posso usare le funzionalita delle nuove API FUNZIONALI
\\l.removeIf(a -> !p.execute(a));
\end{lstlisting}

\noindent Posso usare Function<A,B> di java come funziona func? \newline
Esempio di chiamata:

\begin{lstlisting}[basicstyle=\small,]

public static void main(){
	List<String> strings = new ArrayList<>();
	string.add("ciao");
	string.add("pippo");
	string.add("unive");
	List<Integer> r = map(strings, new Func<String, Integers>{
		@Override 
		public Integer execute(String a){
			return a.length();
		}	
	});
}
\end{lstlisting}


\noindent La seguente funzione data una lista di interi scarta gli elementi minori di zero: questo è il modo per non usare un for con un ciclo if innestato.

\begin{lstlisting}[basicstyle=\small,]

public static void main__filter(){
	 List<Integer> interi  = new ArrayList<>();
	 interi.add(89);
	 interi.add(34);
	 interi.add(-16);
	 interi.add(560);
	 interi.add(-1);
	 interi.add(46);
	 //filter prende una lista e un predicato e produce una lista in uscita
	 List<Integer> l = Filter(ints, new Func<Integer, boolean>(){
	 	@Override
	 	public Boolean execute (Integer a){
	 		return a>=0;
	 	}
	 });
}
\end{lstlisting}

Oppure 

\begin{lstlisting}[basicstyle=\small,]
	Filter2 (interi , new Func<Integer, Boolean>(){
		@Override
		public Boolean execute (Integer a)
			return a>=0;
	})
\end{lstlisting}

\noindent \textbf{Generics Locali (Polimorfismo parametrico di primo ordine)} 

\begin{lstlisting}[basicstyle=\small,]

    public static Object ident__ugly(Object o) {
        return o;
    }   
    //con metodo di subtyping che è POLIMORFISMO VERTICALE, 
    //questa funzione NON è sound perché sono costretto a castare ciò che ricevo

    public static <X> X ident(X x) {
        return x;
    }   //con i generics che è POLIMORFISMO PARAMETRICO

\end{lstlisting}

\begin{lstlisting}[basicstyle=\small,]

	
	public static void main__ident	(){
		Cane fido = new Cane();
		Cane c = (Cane) ident__ugly(fido);  //ritorna un cane castando
		Cane c2 = ident(fido);  //ritorna un cane senza dover castare
		Gatto g = ident(new Gatto());
	}
\end{lstlisting}





















