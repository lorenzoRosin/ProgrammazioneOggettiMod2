

\newpage
\section{APPROFONDIMENTI}
In questa sezione inserirò il materiale utile trovato nel libro e/o su internet sotto forma di approfondimento. 


\noindent \textbf{COSA STUDIARE BENE} \newline
Per l'esame bisogna studiare: \newline
\textbullet\ Collection \newline
\textbullet\ Thread \newline
\textbullet\ ThreadPool \newline
\textbullet\ Design pattern: factory (sul sito ha scritto: metodi statici come costruttori)\newline
\textbullet\ Design pattern: singleton \newline
\textbullet\ Design pattern: command \newline
\textbullet\ Programmazione funzionale: lambda \newline
\textbullet\ Programmazione funzionale: anonymus classes \newline
\textbullet\ Programmazione funzionale: function objects \newline


\subsection{COLLECTION}
\noindent Le collection le chiamano anche contenitori.


\subsection{FACTORY}
Esistono 3 implementazioni con nomi diverse di questo design pattern, le quali vengono chiamate anche: Smart Constructor. \newline
\subsubsection{FACTORY}
\begin{lstlisting}
/* Lo scopo è nascondere l'implementazione e come
 * viene effettivamente creato un oggetto */
public class FruitFactory {

  public enum FruitType{
  	orange, apple, mandarin
  }
  public static Fruit makeFruint(FruitType wichFruit){
  	switch(wichFruit){
  		case mandarin: return new Mandarin();
  		case apple:    return new Apple();
  		case orange:   return new Orange();
  	}
  }
}
\end{lstlisting}
\subsubsection{FACTORY METHODS}
\noindent il factory  methods di prima è bello perchè il cliente ha la sola dipendenza dalla classe FruitFactory. Se c'è però bisogno di aggiungere un frutto bisognerà modificare quella classe. Questo va contro al principio di "estendere senza modificare". Per fare ciò è stato inventato il seguente design pattern, che permette di aggiungere funzionalità estendendo le classi, senza bisogno di modificarle.
\begin{lstlisting}
abstract class FruitPicker {

  protected abstract Fruit makeFruit();

  public void pickFruit() {
    private final Fruit f = makeFruit(); // The fruit we will work on..
    <bla bla bla>
  }
}

class OrangePicker extends FruitPicker {

  @Override
  protected Fruit makeFruit() {
    return new Orange();
  }
}
\end{lstlisting}
\subsubsection{ABSTRACT FACTORY}
\begin{lstlisting}
interface PlantFactory {

  Plant makePlant();

  Picker makePicker(); 

}

public class AppleFactory implements PlantFactory {
  Plant makePlant() {
    return new Apple();
  }

  Picker makePicker() {
    return new ApplePicker();
  }
}

public class OrangeFactory implements PlantFactory {
  Plant makePlant() {
    return new Orange();
  }

  Picker makePicker() {
    return new OrangePicker();
  }
}
\end{lstlisting}
\subsubsection{STATIC FACTORY METHODS}
\noindent Non penso centri con questo tipo di design pattern, ma è comunque un metodo con un nome simile.
\begin{lstlisting}
/* Il costruttore di una classe ha sempre il 
 * nome della classe stessa, posso quindi avere
 * costruttori che differiscono solo per il numero
 * parametri presenti. Con l'utilizzo delle funzioni 
 * statiche posso avere metodi di istanza con nomi 
 * esemplificativi che ritornano istanze della 
 * classe. 
 * Con costruttori statici posso anche cachare 
 * gli oggetti che creo, non devo per forza
 * ritornare istanze sempre diverse di oggetti
 * un'altro vantaggio è che posso cambiare 
 * l'implementazione interna senza dover cambiare
 * le API esposte. 
 * Un altro vantaggio è che posso ritornare qualsiasi
 * tipo che voglio, anche sottotipi, contrariamente
 * ai costruttori che ritornano lo stesso tipo della
 * classe */
 
 /* ESEMPIO SENZA METODI STATICI */
class Color {
    private final int hex;
    Color(String rgb) {
        this(Integer.parseInt(rgb, 16));
    }
    Color(int red, int green, int blue) {
        this(red << 16 + green << 8 + blue);
    }
    Color(int h) {
        this.hex = h;
    }
}

/* ESEMPIO CON METODI STATICI */

class Color {
    private final int hex;
    static Color makeFromRGB(String rgb) {
        return new Color(Integer.parseInt(rgb, 16));
    }
    static Color makeFromPalette(int red, int green, int blue) {
        return new Color(red << 16 + green << 8 + blue);
    }
    static Color makeFromHex(int h) {
        return new Color(h);
    }
    private Color(int h) {
        return new Color(h);
    }
} 

\end{lstlisting}
\subsection{COMMAND}
Questo design pattern prevede di fare un decoupling tra un attore che produce azioni ed un consumatore. Genereremo infatti vari comandi che nascondono all'utilizzatore la loro implementazione, permettendo anche al codice di essere il più mantenibile possibile. \newline
Creando vari oggetti che implementano vari azioni abbiamo anche la possibilità di salvarli in liste, code etc.. Questo design prevede vari attori: \newline
\textbullet\ Command: E' l'implementazione del comando che verrà eseguito \newline
\textbullet\ Receiver: E' la classe responsabile dell'esecuzione dei comandi \newline
\textbullet\ Invoker: E' la classe che triggera l'esecuzione del comando \newline
\textbullet\ Client: E' la classe che istanzia i comandi e le azione che vengono eseguite dal Receiver. \newline
\begin{lstlisting}
/* COMMAND */
public interface Command{
	public void execute();
}

/* RECEIVER */
public void performAction(Command e){
	e.execute();
}

/* CLIENT */
public void startAfter100Mills(){
	setTimer(()->{
		System.out.println("100 Mill sec as gone");
	});
}

/* INVOKER */
/* E' l'oggetto che invoca dopo 100 ms performAction*/
\end{lstlisting}
\subsection{FUNCTION OBJECT}
\noindent Bisogna inanzi tutto precisare che non è un vero design pattern, ma una implementazione. I functional objects sono oggetti usati solo come funzioni. Essi magari implementano un'interfaccia funzionale e poi vengono passati nel codice ed usati solo per il loro unico metodo. Questi oggetti non si memorizzano variabili interne ma elaborano solamente i dati in ingresso al loro metodo. vediamone un esempio:
\begin{lstlisting}
	public interface Function{
		public int exec(int param);
	}
	
	public class SumTwo implements Function{
		@Override
		public int exec(int param){
			return param+2;
		}
	}
	
	public static void main(String[] strings){
		SumTwo obj = new SumTwo();
		System.out.println(obj.exec(10));
	}
\end{lstlisting}

\subsection{EQUALS, HASCODE E TOSTRING}
\noindent \textbullet\ \textit{equals}: se non sovrascritto ritorna true quando due classi sono esattamente la stessa istanza. E' bene sovrascriverlo ogni volta che una classe può avere condizioni di equità logiche. Ad esempio due stringhe identiche ma instanziate separatamente risultano uguali usando equals solo perchè esso è sovrascritto dalla classe String. Consiglio: 
\begin{lstlisting}
public class Complex{
...
	@Override
	public boolean equals(Object o){
		if(o == this)
			return true;
		if(!(o instanceof Complex))
			return false;
		Complex c = (Complex) o;
		... /* elaborazioni */	

	}
}
\end{lstlisting}
\noindent \textbullet\ \textit{hashCode}: Quando faccio over-ride di equals devo farlo anche di hashCode perchè due classi, che secondo il metodo equals sono uguali, devono avere anche lo stesso hashCode. Non è richiesto però che due istanze diverse abbiano hasCode diversi! \newline
\textbullet\ \textit{toString}: E' implementato nella classe object e quindi in ogni classe da noi sviluppata. E' meglio però sovrascriverlo sempre.

\subsection{ENUM}
\noindent Esempi di enum:
\begin{lstlisting}
	public enum Prova{
		prova1, prova2, prova3
	}
	
	public void esempio(Prova var){
		for(Prova temp: Prova.values()){
			if(temp.equals(prova1))
		}
	}
	
	public enum Planet{
		MERCURY(10, 30),
		VENUS(33, 44);
		private final mass;
		private final radius;
		/*Costruttore*/
		Planet(int pro, int vola){
			mass = pro;
			radius = vola;
		}
	}
\end{lstlisting}

\subsection{CLASSI IMMUTABILI}
\noindent Ricorda: cerca di non tornare reference a strutture dati anche se sono final, perchè è facile modificarle lo stesso! Cerca di lavorare con classi immutabili, che una volta costruite non possono variare, agevolando cosi anche la programmazione multi-thread che non richiede più la sincronizzazione! Per fare questo, se un metodo ha bisogno di modificare lo stato della mia istanza, invece che modificarla veramente posso ritornare un nuovo oggetto con un nuovo stato iniziale. Implemento quindi il costruttore-copia.

\subsection{THREAD}
\noindent Ricorda che la sincronizzazione serve non solo per i mutex ma anche per la gestione della memoria!
\begin{lstlisting}
/* Cosi non funziona!!!! */
public class StopThread{
	private static boolean stopRequested;
	
	public static main(String[] args){
	Thread temp = new Thread(()->{
		int i=0;
		while(!stopRequested)
		i++;
	});
	temp.start();
	stopRequested = true;
	}
}

/* Cosi funziona!!!! */
public class StopThread{
	private static boolean stopRequested;
	private static synchronized void stop(){
		stopRequested = true;
	}
	private static synchronized boolean isStop(){
		return stopRequested;
	}	
	public static main(String[] args){
	Thread temp = new Thread(()->{
		int i=0;
		while(!isStop())
		i++;
	});
	temp.start();
	stop();
	}
}
\end{lstlisting}

\noindent Ricordati che l'operazione ++ non è atomica! Mentre incrementa la variabile potrebbe partire un'altro thread. Bisogna quindi usare la synchronized in questi casi. \newline
Ricordarsi che se viene invocato un \textit{notify()} e poi un \textit{wait()} il wait continua ad aspettare, per questo è auspicabile mettere il \textit{wait()} all'interno di un ciclo while (o anche un if) che ne controlla continuamente la condizione anche prima di entrare in pausa. Sarebbe meglio usare un while che cosi posso controllare la correttezza sia in ingresso che in uscita.

\subsection{ALTRO}
\noindent Quando lanci eccezioni fai operazioni etc.. sarebbe meglio non lasciare l'oggetto in uno stato inconsistente. E' sempre meglio lanciare eccezioni in posizioni dove l'oggetto non è ancora stato modificato, in modo da non comprometterlo: è giusto quindi fare dei check iniziali di alcune variabili critiche e lanciare le eccezioni da li. 
\begin{lstlisting}
/* cosi rimane consistente! */
public Object[] popTotObject(int num ){
	if(num>size)
		throw new TooPopPerTime();
	size -= num;
	....
}
\end{lstlisting}