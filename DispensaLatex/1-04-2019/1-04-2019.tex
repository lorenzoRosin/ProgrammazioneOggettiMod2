

\newpage
\section{1-04-2019: HASH MAP}
\textbf{HASH MAP} \newline
Le hash Map sono sempre delle mappe, solo che il tipo di una chiave viene identificato con un interno. Questo può rendere la ricerca più veloce!. \newline
Per cercare si esegue l'hash di quello che voglio cercare (per esempio hashare una stringa), poi vado a cercare in un array indicizzato ( questa operazione costa O(1) costante). \newline
Le l'hash map sono però inefficienti in termini di memoria. 

\noindent Il costruttore dell' hash map è il seguente: 
\begin{lstlisting}
	HashMap(int initalcapacity, float loadFactor)
\end{lstlisting}
Esso costruisce una hash map vuota con una capacità iniziale uguale a quella specificatta e con un fattore di carico anch'esso specificato. Il fattore di carico (load factor) specifica di quanto si deve moltiplicare quando si ingrandisce la mappa. 
\begin{lstlisting}
	HashMap(Map<? extends k, ? extends v> m)
\end{lstlisting}
Costruisce una nuova hash map, popolandola con i valori della mappa passata. Viene chiamato costruttore per copia.

\noindent Si subsume fino al punto che serve (un buon compromesso è subsumere fino all'interfaccia). Se però mi servono dei metodi specifici, non possono subsumere. 

\noindent La classe Object ha un metodo hashcode che tutti gli oggetti ereditano. Serve per hashare this.



\noindent Il professore ha aggiunto il seguente codice nel suo repository github quel giorno: 

\begin{lstlisting}
/* Classe: Main.java */
/* è stata modificata la classe dell'altra volta */
/* Ha aggiunto solo l'hashCode e il main3(), la
 * riporto tutta per completezza */

import java.util.*;

public class Main {

    public static class Plant {
        private int height;

    }

    public static class Animal implements Comparable<Animal> {
        private int weight;
        private String name;

        public Animal(String name, int w) {
            this.name = name;
            this.weight = w;
        }

        public int getWeight() { return weight; }

        public String getName() {
            return name;
        }

        @Override
        public int compareTo(Animal o) {
            return this.weight - o.weight;
        }

        @Override
        public int hashCode() {
            return weight * name.hashCode();
        }

    }

    public static class Dog extends Animal {

        public Dog(String name, int w) {
            super(name, w);
        }

        @Override
        public int hashCode() {
            return super.hashCode();
        }
    }

    public static void main3() {

        Map<Dog, String> m = new HashMap<>();
        Dog emma = new Dog("emma", 10);
        Dog toby = new Dog("toby", 10);
        Dog bob = new Dog("bob", 20);

        m.put(emma, "cecilia");
        m.put(toby, "mihail");
        m.put(bob, "alex");
    }





    public static void main2() {
        MyCollection<Pair<String, Integer>> rubrica = new MyListMap<>();
        rubrica.add(new Pair<>("Alvise", 34712345));
        rubrica.add(new Pair<>("Diego", 987654321));
    }


    public static void main(String[] args) {

        List<Animal> a = new ArrayList<>();
        Collections.sort(a);

        List<Plant> b = new ArrayList<>();
        Collections.sort(b, new Comparator<Plant>() {
            @Override
            public int compare(Plant x, Plant y) {
                return x.height - y.height;
            }
        });

    }
}


\end{lstlisting}
 


