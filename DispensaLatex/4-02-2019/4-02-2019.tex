

\newpage
\section{4-02-2019}
\textbf{DICHIARAZIONE $\neq$ ASSEGNAMENTO} \newline
L'assegnamento fa riferimento alla modifica di una variabile.
\begin{lstlisting}[basicstyle=\small,]

int n		\\ Dichiarazione
int m = n = 1; 	\\ Inizializzazione
n = 2 		\\ Assegnamento

\end{lstlisting}
JAVA è un linguaggio \textit{imperattivo} ad oggetti.

\noindent Java è stato realizzato con un compilatore integrato, che non compila in assembly, questo compilatore invece produce un file sorgente che non è eseguibile direttamente dalla macchina, bensi è eseguibile da una virtual machine, la JVM(\textit{java virtual machine}). In questo modo viene garantita la portabilità del codice in vari computer con CPU diversa (come il Phyton e .NET). \newline
Questa separazione non conta niente per il linguaggio, si riflette solamente sul modello architetturale.

\noindent U.M.L. = unified model language $\Rightarrow$ rappresentazioni di gerarchie di classi. \newline
\digraph{ao}{rankdir=LR;

   a [label="Animali" shape = "record"]; 
   c [label="Cani" shape = "record"]; 
   g [label="Gatti" shape = "record"]; 
   d [label="Dalmata" shape = "record"]; 
   c->a; g->a; d->c;} \newline
\textbullet\ Tutte le sottoclassi sono dei sottoinsiemi. \newline
\textbullet\ Tutte le superclassi sono dei sovrainsiemi. 

\noindent I linguaggi ad oggetti ci permettono di costruire \textit{tipi} e di definire \textit{valori}. 
\begin{lstlisting}[basicstyle=\small,]
	Animale a = new Animale(); \\ in Java gli oggetti sono valori
	\\ dove: Animale -> tipo -> CLASSE
	\\ a = nome variabile
	\\ new Animale() ha un valore -> OGGETTO
\end{lstlisting}

\noindent Compilatore(compiling time): \newline
\textbullet\ controllo sintattico \newline
\textbullet\ controllo dei tipi, cioè che gli insiemi siano corretti \newline
Esecuzione(RunTime):\newline
\textbullet\ Abbiamo a che fare con valori e non con tipi

\noindent I tipi di fatto sono una astrazione del linguaggio. \newline
Il senso di un compilatore è quello di evitare di scrivere castonerie che a livello di esecuzione non avrebbero senso.

\noindent \textit{SOUNDNESS}: un linguaggio è sound quando il compilatore ti da la certezza che funzioni

\noindent \textbf{PARAMETRO IMPLICITO} \newline
 Ogni metodo dichiarato ha sempre un parametro implicito (il parametro \textit{this}). Esso è sotto inteso e viene passato automaticamente, più eventuali parametri che vengono passati all'interno del metodo.
\begin{lstlisting}[basicstyle=\small,]
	public class Animal {
		private int peso;
		...
		public void mangia(Animali a){
			this.peso = this.peso + a.peso;
		}
	}
	
	Cane fido = new Cane();
	a.mangia(fido); 			\\ SUBSUMPTION (assunzione)	
	
\end{lstlisting}

\noindent \textbf{POLIMORFISMO} \newline
L'eredità è un meccanismo che garantisce il funzionamento del \textit{polimorfismo}.\newline
\textbullet\ Polimorfismo per \textit{SUBTYPING} o anche polimorfismo per inclusione: si riferisce al fatto che una espressione il cui tipo sia descritto da una classe A può assumere valori di un qualunque tipo descritto da una classe B sottoclasse di A (Vedi codice appena sopra)\newline 
\textbullet\ Polimorfismo dei \textit{GENERICS}: si riferisce al fatto che il codice del programma può ricevere un tipo come parametro invece che conoscerlo a priori (polimorfismo parametrico). In questo modo non si perde il tipo originario passato dall'oggetto al metodo \newline
\begin{lstlisting}[basicstyle=\small,]
	\\ POLIMORFISMO SUBTYPING
	\\ basato sui sottotipi ereditarieta
	Object ident (Object x){
		return x;
	}

	\\ POLIMORFISMO GENERICS (parametrico)
	\\ non perdo informazioni sui tipi
	<T> T ident (T x){
		return x;
	}
	\\ questa funzione mi permette di riusare il metodo, in questo modo evito 
	\\ di fare CAST, e di sbagliare a farli

\end{lstlisting}

\newpage

