

\newpage
\section{4-02-2019: INTRO}
\textbf{DICHIARAZIONE $\neq$ ASSEGNAMENTO} \newline
L'assegnamento fa riferimento alla modifica di una variabile.
\begin{lstlisting}
int n		   /* Dichiarazione */
int m = n = 1; /* Inizializzazione */
n = 2 		   /* Assegnamento */
\end{lstlisting}

\noindent \textbf{PROGRAMMAZIONE IMPEATTIVA VS FUNZIONALE} \newline
JAVA è un linguaggio \textit{imperattivo} ad oggetti. Questo significa che si programma variando lo stato interno delle varie istanze. In contrapposizione troviamo la programmazione funzionale che si basa sul richiamare e scrivere funzioni che non variano gli stati interni delle istanze. Nella programmazione funzionale sono usati spesso metodi che ritornano copie modificate di un determinato oggetto, senza modificare l'oggetto attuale.

\noindent \textbf{JAVA VIRTUAL MACHINE} \newline
\noindent Java è stato realizzato con un compilatore integrato, che non compila in assembly, questo compilatore invece produce un file sorgente che non è eseguibile direttamente dalla macchina, bensi è eseguibile da una virtual machine, la JVM(\textit{java virtual machine}). In questo modo viene garantita la portabilità del codice in vari computer con CPU diversa (come il Phyton e .NET). \newline
Questa separazione non conta niente per il linguaggio, si riflette solamente sul modello architetturale.

\noindent U.M.L. = unified model language $\Rightarrow$ rappresentazioni di gerarchie di classi. \newline
\digraph{ao}{rankdir=LR;

   a [label="Animali" shape = "record"]; 
   c [label="Cani" shape = "record"]; 
   g [label="Gatti" shape = "record"]; 
   d [label="Dalmata" shape = "record"]; 
   c->a; g->a; d->c;} \newline
\textbullet\ Tutte le sottoclassi sono dei sottoinsiemi. \newline
\textbullet\ Tutte le superclassi sono dei sovrainsiemi. 

\noindent I linguaggi ad oggetti ci permettono di costruire \textit{tipi} e di definire \textit{valori}. 
\begin{lstlisting}
	Animale a = new Animale();
	/* in Java gli oggetti sono valori
	 * dove: Animale -> tipo -> CLASSE
	 * a = nome variabile
	 * new Animale() ha un valore -> OGGETTO */
\end{lstlisting}

\noindent \textbf{COMPILING TIME E RUNTIME} \newline
La gestione di sintassi e di errori viene fatta in due fasi.
Dal compilatore(compiling time): \newline
\textbullet\ Viene eseuito un controllo sintattico \newline
\textbullet\ Viene eseguito controllo dei tipi, cioè che gli insiemi siano corretti\newline
In fase di esecuzione(RunTime):\newline
\textbullet\ Abbiamo a che fare con valori e non con tipi, vengono controllati i "cast"

\noindent I tipi di fatto sono una astrazione del linguaggio. \newline
Il senso di un compilatore è quello di evitare di scrivere castonerie che a livello di esecuzione non avrebbero senso.

\noindent \textbf{SOUNDNESS} \newline
Un linguaggio si dice \textit{sound} quando il compilatore ti da la certezza che in fase di esecuzione il programma sia eseguito correttamente senza possibilità di errori.

\noindent \textbf{PARAMETRO IMPLICITO} \newline
 Ogni metodo dichiarato ha sempre un parametro implicito (il parametro \textit{this}). Esso è sotto inteso e viene passato automaticamente, più eventuali parametri che vengono passati all'interno del metodo.
\begin{lstlisting}
	public class Animal {
		private int peso;
		...
		public void mangia(Animali a){
			this.peso = this.peso + a.peso;
		}
	}
	
	Cane fido = new Cane();
	a.mangia(fido); 			/* SUBSUMPTION (assunzione)	*/
\end{lstlisting}

\noindent \textbf{POLIMORFISMO} \newline
L'eredità è un meccanismo che garantisce il funzionamento del \textit{polimorfismo}.\newline
\textbullet\ Polimorfismo per \textit{SUBTYPING} o anche polimorfismo per inclusione: si riferisce al fatto che una espressione il cui tipo sia descritto da una classe A può assumere valori di un qualunque tipo descritto da una classe B sottoclasse di A (Vedi codice appena sopra)\newline 
\textbullet\ Polimorfismo dei \textit{GENERICS}: si riferisce al fatto che il codice del programma può ricevere un tipo come parametro invece che conoscerlo a priori (polimorfismo parametrico). In questo modo non si perde il tipo originario passato dall'oggetto al metodo \newline
\begin{lstlisting}
	/* POLIMORFISMO SUBTYPING
	 * basato sui sottotipi ereditarietà */
	Object ident (Object x){
		return x;
	}

	/* POLIMORFISMO GENERICS (parametrico)
	 * non perdo informazioni sui tipi */
	<T> T ident (T x){
		return x;
	}
	/* questa funzione mi permette di riusare il 
	 * metodo, in questo modo evito di fare CAST,
	 * e di sbagliare a farli */
\end{lstlisting}

\newpage

